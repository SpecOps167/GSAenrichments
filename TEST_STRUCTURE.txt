All test are similarly structured.  Due to the use of multiprocessing, each test has a sub method to be mapped to multiple workers.

The steps for each test from input to output, start to finish, are as follows:

1) Take in inputs (can be hardcoded or taken in from parsers)
2) Inputs are passed to a general method called either over_rep_test or enrichment_test, which handles all tests of the appropriate type

inputs --> general_test(inputs)

3) From the inputs, the general method identifies the type of statistical test to run.  You can specify if you want to print the eventual output to the console with a boolean as one of the parameters

switch(type)
    case example:
        run example_test
    break;

4) The statistical method is executed, and an array of inputs are built to map to several workers

intput_arr --> [cpu1, cpu2, cpu3, cpu4]

5) For now, the inputs and sub method is mapped to the cpu count (the number of cores on the machine)
6) Each worker will begin running the sub processes and appending its output to a gene ranking array
7) The gene ranking array contains all useful information to be printed out to the console or to an output file.  After the workers are all done, the gene rankings array is passed to a printer class which will handle formatting and printing

cpu1 --> run_submethod(intput_arr[0])
cpu2 --> run_submethod(intput_arr[1])              pool.close() and pool.join()        --> appended to gene rankings
cpu3 --> run_submethod(intput_arr[2])
cpu4 --> run_submethod(intput_arr[3])

8) The printer class first filters out the significant GO terms with multiple hypothesis correction

gene_rankings --> BH filter --> store into significant_value array

9) The printer class outputs to an output file and the console if desired through the boolean in step 3

significant_value_array --> formatting --> printing